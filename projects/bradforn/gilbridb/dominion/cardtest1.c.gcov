        -:    0:Source:cardtest1.c
        -:    0:Graph:cardtest1.gcno
        -:    0:Data:cardtest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include<stdio.h>
        -:    2:#include<stdlib.h>
        -:    3:#include <math.h>
        -:    4:#include "dominion.h"
        -:    5:#include "dominion_helpers.h"
        -:    6:#include "rngs.h"
        -:    7:
        -:    8:
        -:    9:
        -:   10:/****************************************************************
        -:   11://			cmpDeck()
        -:   12://
        -:   13:// Compare contents of the decks 1 and 2 against each other
        -:   14://  returns a 2 if the decks are a perfect match
        -:   15://  returns a 1 if the two decks have the same contents in different order
        -:   16://  returns a 0 if the two decks do NOT have the same contents
        -:   17://  returns a -1 if deck sizes are not equal.
        -:   18:***************************************************************/
function cmpDeck called 11 returned 100% blocks executed 52%
       11:   19:int cmpDeck(int *deck1, int *deck2, int deck1size, int deck2size)
        -:   20:{
       11:   21:	if(deck1size != deck2size) {return -1;}
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
        -:   22:	//Copy decks to decks that can be altered
        -:   23:	int deckP1[MAX_DECK];
        -:   24:	int deckP2[MAX_DECK];
        6:   25:	int deckPpos1 = 0;
        6:   26:	int deckPpos2 = 0;
        -:   27:	int i;
        -:   28:	int j;
        -:   29:
        -:   30:	//Capture current decks in deck holders for all players
       66:   31:	for(i = 0; i < deck1size; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   32:	{
       60:   33:		deckP1[deckPpos1] = deck1[i];//current Player top card = current card of deck
       60:   34:		deckP2[deckPpos2] = deck2[i];//current Player top card = current card of deck
       60:   35:		deckPpos1++;//increase top of deck
       60:   36:		deckPpos2++;//increase top of deck
        -:   37:	}
        -:   38:
        -:   39:
        -:   40:	//Check if perfect match
       60:   41:	for(i = 0; i < deck1size; i++)
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:   42:	{
        -:   43:		//printf("FOR TESTING %d vs %d\n", deckP1[i], deckP2[i]);
       60:   44:		if(deckP1[i] != deckP2[i])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   45:		{
    #####:   46:			break; //Not perfect match
        -:   47:		}
       60:   48:		else if(i == (deck1size -1)) // if this is last iteration
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        -:   49:		{
        6:   50:			return 2; // Decks are a perfect match
        -:   51:		}
        -:   52:	}
        -:   53:
    #####:   54:	for(i =0; i < deck1size; i++)
branch  0 never executed
branch  1 never executed
        -:   55:	{
    #####:   56:		int conclusion = 0;
    #####:   57:		for(j = 0; j < deck1size; j++)
branch  0 never executed
branch  1 never executed
        -:   58:		{
    #####:   59:			if(deckP1[i] == deckP2[j])
branch  0 never executed
branch  1 never executed
        -:   60:			{
    #####:   61:				deckP2[j] = -1; // Removes it as an option
    #####:   62:				conclusion = 1;
    #####:   63:				break;
        -:   64:			}
        -:   65:		}
    #####:   66:		if(conclusion == 0){return 0;}// happens when inner if statement was not true
branch  0 never executed
branch  1 never executed
        -:   67:	}
    #####:   68:	return 1;
        -:   69:}
        -:   70:
        -:   71:
        -:   72:
        -:   73:
        -:   74:/******************************************************************
        -:   75://			smithyTest()
        -:   76://			
        -:   77:// This function should test mutliple things regarding the Smithy card implementation:
        -:   78://
        -:   79:// Test that hand, deck, and discard score add up to the correct total
        -:   80:// Test that the cards of other players are left unaffected 
        -:   81:// Test that the number of total players is not changed
        -:   82://
        -:   83:// This should suffice to test a large part of the possible places for error.
        -:   84:******************************************************************/
        -:   85:
function testsmithy called 4 returned 100% blocks executed 82%
        4:   86:void testsmithy(int num_players, int hand_size_in, int smithy_pos)
        -:   87:{
        4:   88:	printf("Tests for: %d players, %d hand size, %d smithy card position\n", num_players, hand_size_in, smithy_pos);
call    0 returned 100%
        -:   89:	int i;
        -:   90:	int j;
        -:   91:	int holder;
        4:   92:	int player_holder = 0;	
        4:   93:	int bonus[2] = {0,0}; // *bonus satisfier
        -:   94:
        -:   95:	struct gameState G;
        4:   96:	struct gameState * state = &G;
        4:   97:  	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse,
        -:   98:           great_hall, tribute, smithy};
        4:   99:	initializeGame(num_players, k, 10, &G); //number players, cards, randomSeed, gameState
call    0 returned 100%
        -:  100:
        -:  101:	//Holder number of players before card call
        4:  102:	player_holder = state->numPlayers;
        -:  103:
        4:  104:	int not_smithy = k[0];
        4:  105:	if(k[0] == smithy){not_smithy = k[1];}
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  106:
        -:  107:
        -:  108:	//Manually set hand for player
        4:  109:	state->handCount[0] = 0;
       28:  110:	for(i = 0; i < hand_size_in; i++)
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        -:  111:	{
       24:  112:		if(i == smithy_pos)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        -:  113:		{
        4:  114:			state->hand[0][state->handCount[0]] = smithy;
        4:  115:			state->handCount[0]++;
        -:  116:		}
        -:  117:		else
        -:  118:		{
       20:  119:			state->hand[0][state->handCount[0]] = not_smithy;
       20:  120:			state->handCount[0]++;
        -:  121:		}
        -:  122:	}
        -:  123:
        -:  124:	
        -:  125:	//Initialize Deck holders for all players
        4:  126:	int deckP[num_players][MAX_DECK];
        4:  127:	int deckPpos[num_players];
        4:  128:	int handPCount[num_players];
        4:  129:	int disPCount[num_players];
        -:  130:	
        -:  131:	//Capture current decks in deck holders for all players
       15:  132:	for(j = 0; j < num_players; j++){	
branch  0 taken 73%
branch  1 taken 27% (fallthrough)
       11:  133:		holder = state->deckCount[j];
       11:  134:		handPCount[j] = state->handCount[j];
       11:  135:		disPCount[j] = state->discardCount[j];
      101:  136:		for(i = 0; i < holder; i++)
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
        -:  137:		{
        -:  138:			//FOR TESTING printf("Deck %d card %d\n", j, state->deck[j][i]);
       90:  139:			deckP[j][deckPpos[j]] = state->deck[j][i];//current Player top card = current card of deck
       90:  140:			deckPpos[j]++;//increase top of deck
        -:  141:		}
        -:  142:	}//End for loop
        -:  143:
        -:  144:	//Shuffle Player 1 deck
        4:  145:	holder = cardEffect(smithy, 0,0,0,&G,smithy_pos, bonus);
call    0 returned 100%
        -:  146:	
        -:  147:	//Checks Number of players remains unchanged
        4:  148:	if(player_holder == state->numPlayers)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  149:		printf("Smithy(): PASS when test number of players.\n");
call    0 returned 100%
        -:  150:	else
    #####:  151:		printf("Smithy(): FAIL when test number of players.\n");
call    0 never executed
        -:  152:
        -:  153:	//printf("Score read: %d\n", holder);
        4:  154:	if(state->handCount[0] >= (handPCount[0] + 2))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  155:	{
        4:  156:		if(state->handCount[0] > (handPCount[0] + 3))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  157:			printf("Smithy(): FAIL when test added more than 3 cards.\n");
call    0 never executed
        -:  158:		else
        4:  159:			printf("Smithy(): PASS when test add 3 cards.\n");
call    0 returned 100%
        -:  160:	}
        -:  161:	else
    #####:  162:		printf("Smithy(): FAIL when test add 3 cards.\n");
call    0 never executed
        -:  163:
        -:  164:	//printf("Score read: %d\n", holder);
        4:  165:	if(state->handCount[0] == (handPCount[0] + 3))
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2:  166:		printf("Smithy(): FAIL when test no cards were discarded.\n");
call    0 returned 100%
        -:  167:	else
        -:  168:	{
       12:  169:		for(i=0; i < state->handCount[0]; i++) // Deck was set up to only have one smithy card in hand, test to see that card no longer is inside the hand
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  170:		{
       10:  171:			if(state->hand[0][i] == smithy)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  172:			{
    #####:  173:				printf("Smithy(): FAIL when test Smithy card was not discarded.\n");
call    0 never executed
    #####:  174:				break;
        -:  175:			}
       10:  176:			else if(i == (state->handCount[0] - 1))//check for last pass
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        2:  177:				printf("Smithy(): PASS when test Smithy card was discarded.\n");
call    0 returned 100%
        -:  178:		}
        -:  179:	}
        -:  180:
        -:  181:
        -:  182:	//Test that the deck has been changed
        -:  183:	//NOTE: it is possible that the deck will be the exact same afterwards, but the odds are very slim
        4:  184:	player_holder = cmpDeck(deckP[0], state->deck[0], deckPpos[0], state->deckCount[0]);
call    0 returned 100%
        4:  185:	if(player_holder == 2)	
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  186:	{
    #####:  187:		printf("Smithy(): FAIL when testing deck wasn't changed after card played.\n");
call    0 never executed
        -:  188:	}
        -:  189:	else //player_holder is -1 or 0 or 1
        4:  190:		printf("Smithy(): PASS when testing deck was altered for p1.\n");
call    0 returned 100%
        -:  191:	
        -:  192:
        -:  193:
        -:  194:
        -:  195:	//Test state of other players
        -:  196:	//Test Hand Count remains unchanged
        9:  197:	for(i=1; i < num_players; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  198:	{
        6:  199:		if(handPCount[i] != state->handCount[i])
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        -:  200:		{
        1:  201:			printf("Smithy(): FAIL when test hand Count changed for a different player.\n");
call    0 returned 100%
        1:  202:			break;
        -:  203:		}
        5:  204:		if(i == (num_players - 1)) //Last Pass
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        3:  205:			printf("Smithy(): PASS when test hand Count didn't change for all other players.\n");
call    0 returned 100%
        -:  206:			
        -:  207:			
        -:  208:	}
        -:  209:
        -:  210:	
        -:  211:
        -:  212:
        -:  213:
        -:  214:
        -:  215:
        -:  216:	//Test Discard Count remains unchanged for other players
       11:  217:	for(i=1; i < num_players; i++)
branch  0 taken 64%
branch  1 taken 36% (fallthrough)
        -:  218:	{
        7:  219:		if(disPCount[i] != state->discardCount[i])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  220:		{
    #####:  221:			printf("Smithy(): FAIL when test discard Count changed for a different player.\n");
call    0 never executed
    #####:  222:			break;
        -:  223:		}
        7:  224:		if(i == (num_players - 1)) //Last Pass
branch  0 taken 57% (fallthrough)
branch  1 taken 43%
        4:  225:			printf("Smithy(): PASS when test discard Count didn't change for all other players.\n");
call    0 returned 100%
        -:  226:			
        -:  227:			
        -:  228:	}
        -:  229:
        -:  230:	//Test State of other player decks
       10:  231:	for(i=1; i < num_players; i++)
branch  0 taken 70%
branch  1 taken 30% (fallthrough)
        -:  232:	{		
        7:  233:		player_holder = cmpDeck(deckP[i], state->deck[i], deckPpos[i], state->deckCount[i]);
call    0 returned 100%
        7:  234:			if(player_holder == -1)	
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        -:  235:			{
        1:  236:				printf("Smithy(): FAIL when testing deck Count changed for a different player\n");
call    0 returned 100%
        1:  237:				break;
        -:  238:			}
        6:  239:			if(player_holder == 0)	
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  240:			{
    #####:  241:				printf("Smithy(): FAIL when testing deck contents changed for a different player.\n");
call    0 never executed
    #####:  242:				break;
        -:  243:			}
        6:  244:			if(player_holder == 1)	
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  245:			{
    #####:  246:				printf("Smithy(): FAIL when testing deck order changed for a different player.\n");
call    0 never executed
    #####:  247:				break;
        -:  248:			}
        6:  249:			if((player_holder == 2) && (i == (num_players - 1)))
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        3:  250:				printf("Smithy(): PASS when testing decks were not altered for all other players.\n");
call    0 returned 100%
        -:  251:	}
        -:  252:			
        4:  253:}
        -:  254:
function main called 1 returned 100% blocks executed 100%
        1:  255:int main(int argc, char *argv[])
        -:  256:{
        1:  257:    testsmithy(3, 5, 0);
call    0 returned 100%
        1:  258:    testsmithy(4, 10, 2);
call    0 returned 100%
        1:  259:    testsmithy(2, 8, 7);
call    0 returned 100%
        1:  260:    testsmithy(2, 1, 0);
call    0 returned 100%
        1:  261:    return 0;
        -:  262:}
        -:  263:
        -:  264:
        -:  265:
